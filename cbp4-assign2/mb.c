#include<stdio.h>
int main(){
	int a = 0;
	int b = 0;
	int i = 0;
	/*
	the asemble code (for loop) is generated by standard gcc optimization
	.L4:
		movl	-12(%rbp), %eax
		andl	$7, %eax
		testl	%eax, %eax
		jne	.L3
		addl	$2, -8(%rbp)
	.L3:
		addl	$3, -4(%rbp)
		addl	$1, -12(%rbp)
	.L2:
		cmpl	$999999, -12(%rbp)
		jle	.L4
	*/

	for(i = 0; i<1000000; i++){		
		if(i%8==0)
			b +=2;
		a+=3;
	}
	printf("%d", a);
	printf("%d", i);
	printf("%d", b);
	return 0;
}
/*
this code iterates 1000000 times, hence there are 2000000 conditional branches (1000000 for for loop, 1000000 for if condition)

the first conditional branch(for loop) will have branch history as TTTTTT, and itâ€™s PC will not change either, when the predictor is trained to reach steady state, the the branch prediction will always be correct.

In terms of the second conditional branch (if condition), patterns are TTTTTT, TTTTTN, TTTTNT, TTTNTT, TTNTTT, TNTTTT, NTTTTT. As the PHT is trained to reach steady state, TTTTTN, TTTTNT, TTTNTT, TTNTTT, TNTTTT, NTTTTT will be trained to be strongly taken with no misprediction. However, there is one misprediction for TTTTTT every eighth time. 

below are the simulation results for 2 level predictor
	NUM_INSTRUCTIONS: 			8312484
	NUM_CONDITIONAL_BR: 		2035257
	2LEVEL NUM_MISPREDICTIONS: 	128926
	2LEVEL MISPRED_PER_1K_INST 	15.51

Theoretically, there will be 1 misprediction out of 16 conditional branches, according to the result, there are 128926 misprediction out of 2035257 condtional branches, which mean there is aroud 1 misprediction out of 16 conditional branches. which proves the correctness of two level predictor.*/



/* below are the full assembly codes
	.file	"mb.c"
	.section	.rodata
.LC0:
	.string	"%d"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$0, -4(%rbp)
	movl	$0, -8(%rbp)
	movl	$0, -12(%rbp)
	movl	$0, -12(%rbp)
	jmp	.L2
.L4:
	movl	-12(%rbp), %eax
	andl	$7, %eax
	testl	%eax, %eax
	jne	.L3
	addl	$2, -8(%rbp)
.L3:
	addl	$3, -4(%rbp)
	addl	$1, -12(%rbp)
.L2:
	cmpl	$999999, -12(%rbp)
	jle	.L4
	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	-12(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	-8(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Debian 6.3.0-18) 6.3.0 20170516"
	.section	.note.GNU-stack,"",@progbits*/
